<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/js/vendor/picturefill.js - Mithril Components</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Mithril Components"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/controller.html">controller</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Datatable.html">Datatable</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: public/js/vendor/picturefill.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! Picturefill - Responsive Images that work today.
*  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
*  License: MIT/GPLv2
*  Spec: http://picture.responsiveimages.org/
*/
(function( w, doc ) {
    // Enable strict mode
    &quot;use strict&quot;;

    // If picture is supported, well, that&#x27;s awesome. Let&#x27;s get outta here...
    if ( w.HTMLPictureElement ) {
        return;
    }

    // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
    doc.createElement( &quot;picture&quot; );

    // local object for method references and testing exposure
    var pf = {};

    // namespace
    pf.ns = &quot;picturefill&quot;;

    // srcset support test
    pf.srcsetSupported = new w.Image().srcset !== undefined;

    // just a string trim workaround
    pf.trim = function( str ) {
        return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, &quot;&quot; );
    };

    // just a string endsWith workaround
    pf.endsWith = function( str, suffix ) {
        return str.endsWith ? str.endsWith( suffix ) : str.indexOf( suffix, str.length - suffix.length ) !== -1;
    };

    /**
     * Shortcut method for matchMedia ( for easy overriding in tests )
     */
    pf.matchesMedia = function( media ) {
        return w.matchMedia &amp;&amp; w.matchMedia( media ).matches;
    };

    /**
     * Shortcut method for &#x60;devicePixelRatio&#x60; ( for easy overriding in tests )
     */
    pf.getDpr = function() {
        return ( w.devicePixelRatio || 1 );
    };

    /**
     * Get width in css pixel value from a &quot;length&quot; value
     * http://dev.w3.org/csswg/css-values-3/#length-value
     */
    pf.getWidthFromLength = function( length ) {
        // If no length was specified, or it is 0, default to &#x60;100vw&#x60; (per the spec).
        length = length &amp;&amp; parseFloat( length ) &gt; 0 ? length : &quot;100vw&quot;;

        /**
        * If length is specified in  &#x60;vw&#x60; units, use &#x60;%&#x60; instead since the div we’re measuring
        * is injected at the top of the document.
        *
        * TODO: maybe we should put this behind a feature test for &#x60;vw&#x60;?
        */
        length = length.replace( &quot;vw&quot;, &quot;%&quot; );

        // Create a cached element for getting length value widths
        if ( !pf.lengthEl ) {
            pf.lengthEl = doc.createElement( &quot;div&quot; );
            doc.documentElement.insertBefore( pf.lengthEl, doc.documentElement.firstChild );
        }

        // Positioning styles help prevent padding/margin/width on &#x60;html&#x60; from throwing calculations off.
        pf.lengthEl.style.cssText = &quot;position: absolute; left: 0; width: &quot; + length + &quot;;&quot;;
        // Using offsetWidth to get width from CSS
        return pf.lengthEl.offsetWidth;
    };

    // container of supported mime types that one might need to qualify before using
    pf.types =  {};

    // Add support for standard mime types.
    pf.types[&quot;image/jpeg&quot;] = true;
    pf.types[&quot;image/gif&quot;] = true;
    pf.types[&quot;image/png&quot;] = true;

    // test svg support
    pf.types[ &quot;image/svg+xml&quot; ] = doc.implementation.hasFeature(&quot;http://www.w3.org/TR/SVG11/feature#Image&quot;, &quot;1.1&quot;);

    // test webp support, only when the markup calls for it
    pf.types[ &quot;image/webp&quot; ] = function() {
        // based on Modernizr&#x27;s lossless img-webp test
        // note: asynchronous
        var img = new w.Image(),
            type = &quot;image/webp&quot;;

        img.onerror = function() {
            pf.types[ type ] = false;
            picturefill();
        };
        img.onload = function() {
            pf.types[ type ] = img.width === 1;
            picturefill();
        };
        img.src = &quot;data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=&quot;;
    };

    /**
     * Takes a source element and checks if its type attribute is present and if so, supported
     * Note: for type tests that require a async logic,
     * you can define them as a function that&#x27;ll run only if that type needs to be tested. Just make the test function call picturefill again when it is complete.
     * see the async webp test above for example
     */
    pf.verifyTypeSupport = function( source ) {
        var type = source.getAttribute( &quot;type&quot; );
        // if type attribute exists, return test result, otherwise return true
        if ( type === null || type === &quot;&quot; ) {
            return true;
        } else {
            // if the type test is a function, run it and return &quot;pending&quot; status. The function will rerun picturefill on pending elements once finished.
            if ( typeof( pf.types[ type ] ) === &quot;function&quot; ) {
                pf.types[ type ]();
                return &quot;pending&quot;;
            } else {
                return pf.types[ type ];
            }
        }
    };

    /**
    * Parses an individual &#x60;size&#x60; and returns the length, and optional media query
    */
    pf.parseSize = function( sourceSizeStr ) {
        var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
        return {
            media: match &amp;&amp; match[1],
            length: match &amp;&amp; match[2]
        };
    };

    /**
     * Takes a string of sizes and returns the width in pixels as a number
     */
    pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
        // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
        //                            or (min-width:30em) calc(30% - 15px)
        var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
            winningLength;

        for ( var i = 0, len = sourceSizeList.length; i &lt; len; i++ ) {
            // Match &lt;media-condition&gt;? length, ie ( min-width: 50em ) 100%
            var sourceSize = sourceSizeList[ i ],
                // Split &quot;( min-width: 50em ) 100%&quot; into separate strings
                parsedSize = pf.parseSize( sourceSize ),
                length = parsedSize.length,
                media = parsedSize.media;

            if ( !length ) {
                    continue;
            }
            if ( !media || pf.matchesMedia( media ) ) {
                // if there is no media query or it matches, choose this as our winning length
                // and end algorithm
                winningLength = length;
                break;
            }
        }

        // pass the length to a method that can properly determine length
        // in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
        return pf.getWidthFromLength( winningLength );
    };

    pf.parseSrcset = function( srcset ) {
        /**
        * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG &#x60;srcset&#x60;
        * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
        *
        * 1. Let input (&#x60;srcset&#x60;) be the value passed to this algorithm.
        * 2. Let position be a pointer into input, initially pointing at the start of the string.
        * 3. Let raw candidates be an initially empty ordered list of URLs with associated 
        *    unparsed descriptors. The order of entries in the list is the order in which entries 
        *    are added to the list.
        */
        var candidates = [];

        while ( srcset !== &quot;&quot; ) {
            srcset = srcset.replace(/^\s+/g,&quot;&quot;);

            // 5. Collect a sequence of characters that are not space characters, and let that be url.
            var pos = srcset.search(/\s/g),
                url, descriptor = null;

            if ( pos !== -1 ) {
                url = srcset.slice( 0, pos );

                var last = url[ url.length - 1 ];

                // 6. If url ends with a U+002C COMMA character (,), remove that character from url
                // and let descriptors be the empty string. Otherwise, follow these substeps
                // 6.1. If url is empty, then jump to the step labeled descriptor parser.

                if ( last === &quot;,&quot; || url === &quot;&quot; ) {
                    url = url.replace(/,+$/, &quot;&quot;);
                    descriptor = &quot;&quot;;
                }
                srcset = srcset.slice( pos + 1 );

                // 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and 
                // let that be descriptors.
                if ( descriptor === null ) {
                    var descpos = srcset.indexOf(&quot;,&quot;);
                    if ( descpos !== -1 ) {
                        descriptor = srcset.slice( 0, descpos );
                        srcset = srcset.slice( descpos + 1 );
                    } else {
                        descriptor = srcset;
                        srcset = &quot;&quot;;
                    }
                }
            } else {
                url = srcset;
                srcset = &quot;&quot;;
            }

            // 7. Add url to raw candidates, associated with descriptors.
            if ( url || descriptor ) {
                candidates.push({
                    url: url,
                    descriptor: descriptor
                });
            }
        }
        return candidates;
    };

    pf.parseDescriptor = function( descriptor, sizes ) {
        // 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list 
        // is the order in which entries are added to the list.
        var sizeDescriptor = descriptor &amp;&amp; descriptor.replace(/(^\s+|\s+$)/g, &quot;&quot;),
            widthInCssPixels = sizes ? pf.findWidthFromSourceSize( sizes ) : &quot;100%&quot;,
            resCandidate;

            if ( sizeDescriptor ) {
                var splitDescriptor = sizeDescriptor.split(&quot; &quot;);

                for (var i = splitDescriptor.length + 1; i &gt;= 0; i--) {

                    var curr = splitDescriptor[ i ],
                        lastchar = curr &amp;&amp; curr.slice( curr.length - 1 );

                    if ( lastchar === &quot;w&quot; || lastchar === &quot;x&quot; ) {
                        resCandidate = curr;
                    }
                    if ( sizes &amp;&amp; resCandidate ) {
                        // get the dpr by taking the length / width in css pixels
                        resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
                    } else {
                        // get the dpr by grabbing the value of Nx
                        var res = curr &amp;&amp; parseFloat( curr, 10 );

                        resCandidate = res &amp;&amp; !isNaN( res ) &amp;&amp; lastchar === &quot;x&quot; || lastchar === &quot;w&quot; ? res : 1;
                    }
                }
            } else {
                resCandidate = 1;
            }
        return resCandidate;
    };

    /**
     * Takes a srcset in the form of url/
     * ex. &quot;images/pic-medium.png 1x, images/pic-medium-2x.png 2x&quot; or
     *     &quot;images/pic-medium.png 400w, images/pic-medium-2x.png 800w&quot; or
     *     &quot;images/pic-small.png&quot;
     * Get an array of image candidates in the form of
     *      {url: &quot;/foo/bar.png&quot;, resolution: 1}
     * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
     * If sizes is specified, resolution is calculated
     */
    pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
        var candidates = pf.parseSrcset( srcset ),
            formattedCandidates = [];

        for ( var i = 0, len = candidates.length; i &lt; len; i++ ) {
            var candidate = candidates[ i ];

            formattedCandidates.push({
                url: candidate.url,
                resolution: pf.parseDescriptor( candidate.descriptor, sizes )
            });
        }
        return formattedCandidates;
    };

    /*
     * if it&#x27;s an img element and it has a srcset property,
     * we need to remove the attribute so we can manipulate src
     * (the property&#x27;s existence infers native srcset support, and a srcset-supporting browser will prioritize srcset&#x27;s value over our winning picture candidate)
     * this moves srcset&#x27;s value to memory for later use and removes the attr
     */
    pf.dodgeSrcset = function( img ) {
        if ( img.srcset ) {
            img[ pf.ns ].srcset = img.srcset;
            img.removeAttribute( &quot;srcset&quot; );
        }
    };

    /*
     * Accept a source or img element and process its srcset and sizes attrs
     */
    pf.processSourceSet = function( el ) {
        var srcset = el.getAttribute( &quot;srcset&quot; ),
            sizes = el.getAttribute( &quot;sizes&quot; ),
            candidates = [];

        // if it&#x27;s an img element, use the cached srcset property (defined or not)
        if ( el.nodeName.toUpperCase() === &quot;IMG&quot; &amp;&amp; el[ pf.ns ] &amp;&amp; el[ pf.ns ].srcset ) {
            srcset = el[ pf.ns ].srcset;
        }

        if ( srcset ) {
            candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
        }
        return candidates;
    };

    pf.applyBestCandidate = function( candidates, picImg ) {
        var candidate,
            length,
            bestCandidate;

        candidates.sort( pf.ascendingSort );

        length = candidates.length;
        bestCandidate = candidates[ length - 1 ];

        for ( var i = 0; i &lt; length; i++ ) {
            candidate = candidates[ i ];
            if ( candidate.resolution &gt;= pf.getDpr() ) {
                bestCandidate = candidate;
                break;
            }
        }

        if ( !pf.endsWith( picImg.src, bestCandidate.url ) ) {
            picImg.src = bestCandidate.url;
            // currentSrc attribute and property to match
            // http://picture.responsiveimages.org/#the-img-element
            picImg.currentSrc = picImg.src;
        }
    };

    pf.ascendingSort = function( a, b ) {
        return a.resolution - b.resolution;
    };

    /*
     * In IE9, &lt;source&gt; elements get removed if they aren&#x27;t children of
     * video elements. Thus, we conditionally wrap source elements
     * using &lt;!--[if IE 9]&gt;&lt;video style=&quot;display: none;&quot;&gt;&lt;![endif]--&gt;
     * and must account for that here by moving those source elements
     * back into the picture element.
     */
    pf.removeVideoShim = function( picture ) {
        var videos = picture.getElementsByTagName( &quot;video&quot; );
        if ( videos.length ) {
            var video = videos[ 0 ],
                vsources = video.getElementsByTagName( &quot;source&quot; );
            while ( vsources.length ) {
                picture.insertBefore( vsources[ 0 ], video );
            }
            // Remove the video element once we&#x27;re finished removing its children
            video.parentNode.removeChild( video );
        }
    };

    /*
     * Find all picture elements and,
     * in browsers that don&#x27;t natively support srcset, find all img elements
     * with srcset attrs that don&#x27;t have picture parents
     */
    pf.getAllElements = function() {
        var pictures = doc.getElementsByTagName( &quot;picture&quot; ),
            elems = [],
            imgs = doc.getElementsByTagName( &quot;img&quot; );

        for ( var h = 0, len = pictures.length + imgs.length; h &lt; len; h++ ) {
            if ( h &lt; pictures.length ) {
                elems[ h ] = pictures[ h ];
            } else {
                var currImg = imgs[ h - pictures.length ];

                if ( currImg.parentNode.nodeName.toUpperCase() !== &quot;PICTURE&quot; &amp;&amp;
                    ( ( pf.srcsetSupported &amp;&amp; currImg.getAttribute( &quot;sizes&quot; ) ) ||
                    currImg.getAttribute( &quot;srcset&quot; ) !== null ) ) {
                        elems.push( currImg );
                }
            }
        }
        return elems;
    };

    pf.getMatch = function( picture ) {
        var sources = picture.childNodes,
            match;

        // Go through each child, and if they have media queries, evaluate them
        for ( var j = 0, slen = sources.length; j &lt; slen; j++ ) {
            var source = sources[ j ];

            // ignore non-element nodes
            if ( source.nodeType !== 1 ) {
                continue;
            }

            // Hitting an &#x60;img&#x60; element stops the search for &#x60;sources&#x60;.
            // If no previous &#x60;source&#x60; matches, the &#x60;img&#x60; itself is evaluated later.
            if ( source.nodeName.toUpperCase() === &quot;IMG&quot; ) {
                return match;
            }

            // ignore non-&#x60;source&#x60; nodes
            if ( source.nodeName.toUpperCase() !== &quot;SOURCE&quot; ) {
                continue;
            }

            var media = source.getAttribute( &quot;media&quot; );

            // if source does not have a srcset attribute, skip
            if ( !source.getAttribute( &quot;srcset&quot; ) ) {
                continue;
            }

            // if there&#x27;s no media specified, OR w.matchMedia is supported
            if ( ( !media || pf.matchesMedia( media ) ) ) {
                var typeSupported = pf.verifyTypeSupport( source );

                if ( typeSupported === true ) {
                    match = source;
                    break;
                } else if ( typeSupported === &quot;pending&quot; ) {
                    return false;
                }
            }
        }

        return match;
    };

    function picturefill( options ) {
        var elements,
            element,
            elemType,
            firstMatch,
            candidates,
            picImg;

        options = options || {};
        elements = options.elements || pf.getAllElements();

        // Loop through all elements
        for ( var i = 0, plen = elements.length; i &lt; plen; i++ ) {
            element = elements[ i ];
            elemType = element.nodeName.toUpperCase();
            firstMatch = undefined;
            candidates = undefined;
            picImg = undefined;

            // expando for caching data on the img
            if ( !element[ pf.ns ] ) {
                element[ pf.ns ] = {};
            }

            // if the element has already been evaluated, skip it
            // unless &#x60;options.force&#x60; is set to true ( this, for example,
            // is set to true when running &#x60;picturefill&#x60; on &#x60;resize&#x60; ).
            if ( !options.reevaluate &amp;&amp; element[ pf.ns ].evaluated ) {
                continue;
            }

            // if element is a picture element
            if ( elemType === &quot;PICTURE&quot; ) {

                // IE9 video workaround
                pf.removeVideoShim( element );

                // return the first match which might undefined
                // returns false if there is a pending source
                // TODO the return type here is brutal, cleanup
                firstMatch = pf.getMatch( element );

                // if any sources are pending in this picture due to async type test(s)
                // remove the evaluated attr and skip for now ( the pending test will
                // rerun picturefill on this element when complete)
                if ( firstMatch === false ) {
                    continue;
                }

                // Find any existing img element in the picture element
                picImg = element.getElementsByTagName( &quot;img&quot; )[ 0 ];
            } else {
                // if it&#x27;s an img element
                firstMatch = undefined;
                picImg = element;
            }

            if ( picImg ) {

                // expando for caching data on the img
                if ( !picImg[ pf.ns ] ) {
                    picImg[ pf.ns ] = {};
                }

                // Cache and remove &#x60;srcset&#x60; if present and we’re going to be doing &#x60;sizes&#x60;/&#x60;picture&#x60; polyfilling to it.
                if ( picImg.srcset &amp;&amp; ( elemType === &quot;PICTURE&quot; || picImg.getAttribute( &quot;sizes&quot; ) ) ) {
                    pf.dodgeSrcset( picImg );
                }

                if ( firstMatch ) {
                    candidates = pf.processSourceSet( firstMatch );
                    pf.applyBestCandidate( candidates, picImg );
                } else {
                    // No sources matched, so we’re down to processing the inner &#x60;img&#x60; as a source.
                    candidates = pf.processSourceSet( picImg );

                    if ( picImg.srcset === undefined || picImg[ pf.ns ].srcset ) {
                        // Either &#x60;srcset&#x60; is completely unsupported, or we need to polyfill &#x60;sizes&#x60; functionality.
                        pf.applyBestCandidate( candidates, picImg );
                    } // Else, resolution-only &#x60;srcset&#x60; is supported natively.
                }

                // set evaluated to true to avoid unnecessary reparsing
                element[ pf.ns ].evaluated = true;
            }
        }
    }

    /**
     * Sets up picture polyfill by polling the document and running
     * the polyfill every 250ms until the document is ready.
     * Also attaches picturefill on resize
     */
    function runPicturefill() {
        picturefill();
        var intervalId = setInterval( function() {
            // When the document has finished loading, stop checking for new images
            // https://github.com/ded/domready/blob/master/ready.js#L15
            picturefill();
            if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
                clearInterval( intervalId );
                return;
            }
        }, 250 );
        if ( w.addEventListener ) {
            var resizeThrottle;
            w.addEventListener( &quot;resize&quot;, function() {
                if (!w._picturefillWorking) {
                    w._picturefillWorking = true;
                    w.clearTimeout( resizeThrottle );
                    resizeThrottle = w.setTimeout( function() {
                        picturefill({ reevaluate: true });
                        w._picturefillWorking = false;
                    }, 60 );
                }
            }, false );
        }
    }

    runPicturefill();

    /* expose methods for testing */
    picturefill._ = pf;

    /* expose picturefill */
    if ( typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot; ) {
        // CommonJS, just export
        module.exports = picturefill;
    } else if ( typeof define === &quot;function&quot; &amp;&amp; define.amd ){
        // AMD support
        define( function() { return picturefill; } );
    } else if ( typeof w === &quot;object&quot; ) {
        // If no AMD and we are in the browser, attach to window
        w.picturefill = picturefill;
    }

} )( this, this.document );

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
